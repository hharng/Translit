<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#	
	var replacements = new Dictionary<string, string>
	{
		{ "abc", "1" },
		{ "bcd", "2" },
		{ "ab", "3" }
	};
	
	var transitions = Parse(replacements);
#>
using System.Text;

// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Generated at <#=DateTime.Now.ToString("u")#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace NickBuhro.Translit
{
	partial class Transliteration
	{
		public static void Append(StringBuilder sb, string text)
		{
			var state = "";			
			for (var i = 0; i < text.Length; i++)
			{
				var c = text[i];
				switch (state)
				{
<# foreach (var g in transitions.GroupBy(t => t.Key.state).OrderBy(g => g.Key)) { #>
					case <#=ToLiteral(g.Key)#>:
						switch (c)
						{
<# foreach (var t in g.OrderBy(gr => gr.Key.input == "").ThenBy(gr => gr.Key.input)) { #>
<# if (t.Key.input != "") { #>
							case <#=ToLiteral(t.Key.input[0])#>:
<# } else { #>
							default:
<# } #>
<# if (t.Value.output.Length > 0) { #>
								sb.Append(<#=ToLiteral(t.Value.output)#>);
<# } #>
<# if (t.Key.input == "") { #>
								sb.Append(c);
<# } #>
<# if (g.Key != t.Value.state) { #>
								state = "<#=t.Value.state#>";
<# } #>
								break;
<# } #>
						}
						break;				
<# } #>
				}
			}

			switch (state)
			{
<# foreach (var p in transitions.Where(t => (t.Key.input == "")).OrderBy(t => t.Key.state)) { #>
				case <#=ToLiteral(p.Key.state)#>:
<# if (p.Value.output != "") { #>
					sb.Append(<#=ToLiteral(p.Value.output)#>);
<# } #>
					break;				
<# } #>
			}
		}
	}
}






<#+
        internal static Dictionary<(string state, string input), (string state, string output)> Parse(IDictionary<string, string> replacements)
        {
            var result = new Dictionary<(string state, string input), (string state, string output)>();
            
            // Generate simple transitions without output

            foreach (var k in replacements.Keys)
            {
                for (var i = 1; i < k.Length; i++)
                {
                    result[(k.Substring(0, i - 1), k[i - 1].ToString())] = (k.Substring(0, i), "");
                }
            }

            // Generate transitions for completed replacements

            foreach (var p in replacements)
            {
                var key = (p.Key.Substring(0, p.Key.Length - 1), p.Key[p.Key.Length - 1].ToString());
                if (!result.ContainsKey(key))
                {
                    result.Add(key, ("", p.Value));
                }
            }

            // Generate fallback transition from initial state

            result.Add(("", ""), ("", ""));

            // Generate transitions to go back

            var states = result.Keys
                .Where(k => k.state != "")
                .Select(k => k.state)
                .Distinct()
                .OrderBy(s => s.Length)
                .ToList();

            foreach (var state in states)
            {
                var tail = state;
                var output = "";
                for (; ; )
                {
                    var replacement = FindReplacement(replacements, tail);

                    output += replacement.output;
                    tail = tail.Substring(replacement.source.Length);

                    var list = result.Where(p => p.Key.state == tail).ToList();
                    if (list.Count > 0)
                    {
                        foreach (var p in list)
                        {
                            var key = (state, p.Key.input);
                            if (!result.ContainsKey(key))
                                result.Add(key, (p.Value.state, output + p.Value.output));
                        }
                        break;
                    }
                }
            }            

            //

            return result;
        }

        private static (string source, string output) FindReplacement(IDictionary<string, string> replacements, string value)
        {
            var s = value;
            while (s.Length > 0)
            {
                if (replacements.TryGetValue(s, out string result))
                    return (s, result);

                s = s.Substring(0, s.Length - 1);
            }

            s = value.Substring(0, 1);
            return (s, s);
        }

		private static string ToLiteral(object input)
        {
            using (var writer = new StringWriter())
            using (var provider = CodeDomProvider.CreateProvider("CSharp"))
            {
                provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
                return writer.ToString();
            }
        }
#>
