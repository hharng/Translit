<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#	
	var langCollection = new (string lang, Func<(string ru, string by, string ua, string bg, string mk), string> selector)[]
	{
		("Russian", t => t.ru),
		("Belorussian", t => t.by),
		("Ukrainian", t => t.ua),
		("Bulgarian", t => t.bg),
		("Macedonian", t => t.mk)
	};
	
	var rules = new Rules();
#>
using System.Text;

// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Generated at <#=DateTime.Now.ToString("u")#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace NickBuhro.Translit
{
	partial class Transliteration
	{
<# foreach (var lang in langCollection) {
	var transitions = Parse(rules.CreateCyrillicToLatinDictionary(lang.selector));
	var states = transitions.GroupBy(t => t.Key.state).OrderBy(g => g.Key).Select(g => g.Key).ToList();	
#>

		internal static string Cyrillic2Latin<#=lang.lang#>(string text)
		{
			var sb = new StringBuilder();
			var state = 0;			
			for (var i = 0; i < text.Length; i++)
			{
				var c = text[i];
				switch (state)
				{
<# foreach (var g in transitions.GroupBy(t => t.Key.state).OrderBy(g => g.Key)) { #>
					case <#=states.IndexOf(g.Key)#>:	// <#=ToLiteral(g.Key)#>
						switch (c)
						{
<# foreach (var t in g.OrderBy(gr => gr.Key.input == "").ThenBy(gr => gr.Key.input)) { #>
<# if (t.Key.input != "") { #>
							case <#=ToLiteral(t.Key.input[0])#>:
<# } else { #>
							default:
<# } #>
<# if (t.Value.output.Length > 0) { #>
								sb.Append(<#=ToLiteral(t.Value.output)#>);
<# } #>
<# if (t.Key.input == "") { #>
								sb.Append(c);
<# } #>
<# if (g.Key != t.Value.state) { #>
								state = <#=states.IndexOf(t.Value.state)#>;	// <#=ToLiteral(t.Value.state)#>;
<# } #>
								break;
<# } #>
						}
						break;				
<# } #>
				}
			}
<# if (states.Count > 1) { #>

			switch (state)
			{
<# foreach (var p in transitions.Where(t => (t.Key.input == "")).OrderBy(t => t.Key.state)) { #>
				case <#=states.IndexOf(p.Key.state)#>:	// <#=ToLiteral(p.Key.state)#>
<# if (p.Value.output != "") { #>
					sb.Append(<#=ToLiteral(p.Value.output)#>);
<# } #>
					break;				
<# } #>
			}
<# } #>
			return sb.ToString();
		}

<#
	transitions = Parse(rules.CreateLatinToCyrillicDictionary(lang.selector));
	states = transitions.GroupBy(t => t.Key.state).OrderBy(g => g.Key).Select(g => g.Key).ToList();	
#>
        internal static string Latin2Cyrillic<#=lang.lang#>(string text)
		{
			var sb = new StringBuilder(text.Length);
			var state = 0;			
			for (var i = 0; i < text.Length; i++)
			{
				var c = text[i];
				switch (state)
				{
<# foreach (var g in transitions.GroupBy(t => t.Key.state).OrderBy(g => g.Key)) { #>
					case <#=states.IndexOf(g.Key)#>:	// <#=ToLiteral(g.Key)#>
						switch (c)
						{
<# foreach (var t in g.OrderBy(gr => gr.Key.input == "").ThenBy(gr => gr.Key.input)) { #>
<# if (t.Key.input != "") { #>
							case <#=ToLiteral(t.Key.input[0])#>:
<# } else { #>
							default:
<# } #>
<# if (t.Value.output.Length > 0) { #>
								sb.Append(<#=ToLiteral(t.Value.output)#>);
<# } #>
<# if (t.Key.input == "") { #>
								sb.Append(c);
<# } #>
<# if (g.Key != t.Value.state) { #>
								state = <#=states.IndexOf(t.Value.state)#>;	// <#=ToLiteral(t.Value.state)#>;
<# } #>
								break;
<# } #>
						}
						break;				
<# } #>
				}
			}
<# if (states.Count > 1) { #>

			switch (state)
			{
<# foreach (var p in transitions.Where(t => (t.Key.input == "")).OrderBy(t => t.Key.state)) { #>
				case <#=states.IndexOf(p.Key.state)#>:	// <#=ToLiteral(p.Key.state)#>
<# if (p.Value.output != "") { #>
					sb.Append(<#=ToLiteral(p.Value.output)#>);
<# } #>
					break;				
<# } #>
			}
<# } #>
			return sb.ToString();
		}
<# } #>
	}
}






<#+
		//----------------------------------------------------------------
		// Transliteration rules
		//----------------------------------------------------------------

		private sealed class Rules
        {
            private readonly Dictionary<string, (string ru, string by, string ua, string bg, string mk)> _data;

            public Rules()
            {
                _data = new Dictionary<string, (string ru, string by, string ua, string bg, string mk)>
                {
                    { "а", ( "a", "a", "a", "a", "a" ) },
                    { "б", ( "b", "b", "b", "b", "b" ) },
                    { "в", ( "v", "v", "v", "v", "v" ) },
                    { "г", ( "g", "h", "h", "g", "g" ) },
                    { "ѓ", ( "", "", "", "", "g`" ) },
                    { "ґ", ( "", "", "g`", "", "" ) },
                    { "д", ( "d", "d", "d", "d", "d" ) },
                    { "е", ( "e", "e", "e", "e", "e" ) },
                    { "ё", ( "yo", "yo", "", "", "" ) },
                    { "є", ( "", "", "ye", "", "" ) },
                    { "ж", ( "zh", "zh", "zh", "zh", "zh" ) },
                    { "з", ( "z", "z", "z", "z", "z" ) },
                    { "s", ( "", "", "", "", "z`" ) },
                    { "и", ( "i", "", "y`", "i", "i" ) },
                    { "й", ( "j", "j", "j", "j", "" ) },
                    { "j", ( "", "", "", "", "j" ) },
                    { "i", ( "i", "i", "i", "i", "" ) },
                    { "ї", ( "", "", "yi", "", "" ) },
                    { "к", ( "k", "k", "k", "k", "k" ) },
                    { "ќ", ( "", "", "", "", "k`" ) },
                    { "л", ( "l", "l", "l", "l", "l" ) },
                    { "љ", ( "", "", "", "", "l`" ) },
                    { "м", ( "m", "m", "m", "m", "m" ) },
                    { "н", ( "n", "n", "n", "n", "п" ) },
                    { "њ", ( "", "", "", "", "n`" ) },
                    { "о", ( "o", "o", "o", "o", "o" ) },
                    { "п", ( "p", "p", "p", "p", "p" ) },
                    { "р", ( "r", "r", "r", "r", "r" ) },
                    { "с", ( "s", "s", "s", "s", "s" ) },
                    { "т", ( "t", "t", "t", "t", "t" ) },
                    { "у", ( "u", "u", "u", "u", "u" ) },
                    { "ў", ( "", "u`", "", "", "" ) },
                    { "ф", ( "f", "f", "f", "f", "f" ) },
                    { "х", ( "x", "x", "x", "x", "x" ) },
                    { "ц", ( "cz, c", "cz, c", "cz, c", "cz, c", "cz, c" ) },
                    { "ч", ( "ch", "ch", "ch", "ch", "ch" ) },
                    { "џ", ( "", "", "", "", "dh" ) },
                    { "ш", ( "sh", "sh", "sh", "sh", "sh" ) },
                    { "щ", ( "shh", "", "shh", "sht", "" ) },
                    { "ъ", ( "``", "", "", "a`", "" ) },
                    { "ы", ( "y`", "y`", "", "", "" ) },
                    { "ь", ( "`", "`", "`", "`", "" ) },
                    { "э", ( "e`", "e`", "", "", "" ) },
                    { "ю", ( "yu", "yu", "yu", "yu", "" ) },
                    { "я", ( "ya", "ya", "ya", "ya", "" ) },
                    { "’", ( "'", "'", "'", "'", "'" ) },
                    { "ѣ", ( "ye", "", "", "ye", "" ) },
                    { "ѳ", ( "fh", "", "", "fh", "" ) },
                    { "ѵ", ( "yh", "", "", "yh", "" ) },
                    { "ѫ", ( "", "", "", "о`", "" ) },
                    { "№", ( "#", "#", "#", "#", "#" ) }
                };
            }

            public Dictionary<string, string> CreateCyrillicToLatinDictionary(Func<(string ru, string by, string ua, string bg, string mk), string> selector)
            {
                var result = new Dictionary<string, string>();
                foreach (var p in _data)
                {
                    var loCyrillic = p.Key;
                    var loLatin = selector(p.Value);

                    if ((loCyrillic == "ц") || (loLatin == "")) continue;

                    var upCyrillic = loCyrillic.ToUpper();
                    var upLatin = char.ToUpper(loLatin[0]) + loLatin.Substring(1);

                    result.Add(loCyrillic, loLatin);
                    if (!result.ContainsKey(upCyrillic))
                    {
                        result.Add(upCyrillic, upLatin);
                    }
                }

                // Ц - рекомендуется использовать С перед буквами I, Е, Y, J; в остальных случаях CZ
                
                var crules = new[] { 'i', 'e', 'y', 'j', 'I', 'E', 'Y', 'J' };
                foreach (var c in crules)
                {
                    result.Add("ц" + c.ToString(), "c" + c.ToString());
                    result.Add("Ц" + c.ToString(), "C" + c.ToString());
                    
                    foreach (var pair in result.Where(p => p.Value[0] == c).ToList())
                    {
                        result["ц" + pair.Key] = "c" + pair.Value;
                        result["Ц" + pair.Key] = "C" + pair.Value;
                    }
                }

                result.Add("ц", "cz");
                result.Add("Ц", "Cz");

                return result;
            }

            public Dictionary<string, string> CreateLatinToCyrillicDictionary(Func<(string ru, string by, string ua, string bg, string mk), string> selector)
            {
                var result = new Dictionary<string, string>();
                foreach (var p in _data)
                {
                    var loCyrillic = p.Key;
                    var loLatin = selector(p.Value);

                    if ((loCyrillic == "ц") || (loLatin == "")) continue;

                    var upCyrillic = loCyrillic.ToUpper();
                    var upLatin = char.ToUpper(loLatin[0]) + loLatin.Substring(1);

                    if (!result.ContainsKey(loLatin))
                    {
                        result.Add(loLatin, loCyrillic);
                    }

                    if (!result.ContainsKey(upLatin))
                    {
                        result.Add(upLatin, upCyrillic);
                    }
                }

                // Ц                

                result.Add("cz", "ц");
                result.Add("Cz", "Ц");
                result.Add("c", "ц");
                result.Add("C", "Ц");

                return result;
            }
        }

		//----------------------------------------------------------------
		// FSM Parser
		//----------------------------------------------------------------

        internal static Dictionary<(string state, string input), (string state, string output)> Parse(IDictionary<string, string> replacements)
        {
            var result = new Dictionary<(string state, string input), (string state, string output)>();
            
            // Generate simple transitions without output

            foreach (var k in replacements.Keys)
            {
                for (var i = 1; i < k.Length; i++)
                {
                    result[(k.Substring(0, i - 1), k[i - 1].ToString())] = (k.Substring(0, i), "");
                }
            }

            // Generate transitions for completed replacements

            foreach (var p in replacements)
            {
                var key = (p.Key.Substring(0, p.Key.Length - 1), p.Key[p.Key.Length - 1].ToString());
                if (!result.ContainsKey(key))
                {
                    result.Add(key, ("", p.Value));
                }
            }

            // Generate fallback transition from initial state

            result.Add(("", ""), ("", ""));

            // Generate transitions to go back

            var states = result.Keys
                .Where(k => k.state != "")
                .Select(k => k.state)
                .Distinct()
                .OrderBy(s => s.Length)
                .ToList();

            foreach (var state in states)
            {
                var tail = state;
                var output = "";
                for (; ; )
                {
                    var replacement = FindReplacement(replacements, tail);

                    output += replacement.output;
                    tail = tail.Substring(replacement.source.Length);

                    var list = result.Where(p => p.Key.state == tail).ToList();
                    if (list.Count > 0)
                    {
                        foreach (var p in list)
                        {
                            var key = (state, p.Key.input);
                            if (!result.ContainsKey(key))
                                result.Add(key, (p.Value.state, output + p.Value.output));
                        }
                        break;
                    }
                }
            }            

            //

            return result;
        }

        private static (string source, string output) FindReplacement(IDictionary<string, string> replacements, string value)
        {
            var s = value;
            while (s.Length > 0)
            {
                if (replacements.TryGetValue(s, out string result))
                    return (s, result);

                s = s.Substring(0, s.Length - 1);
            }

            s = value.Substring(0, 1);
            return (s, s);
        }

		private static string ToLiteral(object input)
        {
            using (var writer = new StringWriter())
            using (var provider = CodeDomProvider.CreateProvider("CSharp"))
            {
                provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
                return writer.ToString();
            }
        }
#>
