<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#	
	var langCollection = new string[]
	{
		"Russian",
		"Belorussian",
		"Ukrainian",
		"Bulgarian",
		"Macedonian"
	};
		
	var definitions = new List<(string name, Dictionary<string, string> replacements)>();

	var rules = new Rules();
	for (var i = 0; i < langCollection.Length; i++)
	{
		definitions.Add((name: "CyrillicToLatin" + langCollection[i], replacements: rules.CreateCyrillicToLatinDictionary(i)));
		definitions.Add((name: "LatinToCyrillic" + langCollection[i], replacements: rules.CreateLatinToCyrillicDictionary(i)));
	}
#>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Generated at <#=DateTime.Now.ToString("u")#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace NickBuhro.Translit
{
	partial class Transliteration
	{
<# foreach (var md in definitions) { var fsm = BuildFSM(md.replacements); #>
		internal static string <#=md.name#>(string text)
		{
			using (var sb = new CustomStringBuilder(text.Length<#= md.name[0] == 'C' ? " * 3" : ""  #>))
            {
			
			var state = 0;			
			for (var i = 0; i < text.Length; i++)
			{
				var c = text[i];
				switch (state)
				{
<# for (var s = 0; s < fsm.Length; s++) { #>
					case <#=s#>:	// <#=ToLiteral(fsm[s].stateName)#>
						switch (c)
						{
<# foreach (var t in fsm[s].transitions.OrderBy(tr => tr.Key)) { #>
							case <#=ToLiteral(t.Key)#>:							
<# foreach (var o in t.Value.text) { #>
								sb.Append(<#=ToLiteral(o)#>);
<# } #>
<# if (s != t.Value.state) { #>
								state = <#=t.Value.state#>;	// <#=ToLiteral(fsm[t.Value.state].stateName)#>
<# } #>
								break;
<# } #>
							default:
<# foreach (var o in fsm[s].fallbackText) { #>
								sb.Append(<#=ToLiteral(o)#>);
<# } #>
								sb.Append(c);
<# if (s != 0) { #>
								state = 0;	// ""
<# } #>
								break;
						}
						break;				
<# } #>
				}
			}
<# if (fsm.Length > 1) { #>

			switch (state)
			{
<# for (var s = 1; s < fsm.Length; s++) { #>
				case <#=s#>:	// <#=ToLiteral(fsm[s].stateName)#>
<# foreach (var o in fsm[s].fallbackText) { #>
					sb.Append(<#=ToLiteral(o)#>);
<# } #>
					break;
<# } #>
			}
<# } #>
			return sb.ToString();
            }
		}

<# } #>
	}
}
<#+	
//----------------------------------------------------------------
// Helpers
//----------------------------------------------------------------

private static string ToLiteral(object input)
{
    using (var writer = new StringWriter())
    using (var provider = CodeDomProvider.CreateProvider("CSharp"))
    {
        provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
        return writer.ToString();
    }
}

//----------------------------------------------------------------
// Transliteration rules
//----------------------------------------------------------------

internal sealed class Rules
{
    private const string _crules = "IEYJ";
	
    private readonly Dictionary<string, string[]> _data = new Dictionary<string, string[]>()
    {
        { "а", new [] { "a", "a", "a", "a", "a" } },
        { "б", new [] { "b", "b", "b", "b", "b" } },
        { "в", new [] { "v", "v", "v", "v", "v" } },
        { "г", new [] { "g", "h", "h", "g", "g" } },
        { "ѓ", new [] { null, null, null, null, "g`" } },
        { "ґ", new [] { null, null, "g`", null, null } },
        { "д", new [] { "d", "d", "d", "d", "d" } },
        { "е", new [] { "e", "e", "e", "e", "e" } },
        { "ё", new [] { "yo", "yo", null, null, null } },
        { "є", new [] { null, null, "ye", null, null } },
        { "ж", new [] { "zh", "zh", "zh", "zh", "zh" } },
        { "з", new [] { "z", "z", "z", "z", "z" } },
        { "s", new [] { null, null, null, null, "z`" } },
        { "и", new [] { "i", null, "y`", "i", "i" } },
        { "й", new [] { "j", "j", "j", "j", null } },
        { "j", new [] { null, null, null, null, "j" } },
        { "i", new [] { "i", "i", "i", "i", null } },
        { "ї", new [] { null, null, "yi", null, null } },
        { "к", new [] { "k", "k", "k", "k", "k" } },
        { "ќ", new [] { null, null, null, null, "k`" } },
        { "л", new [] { "l", "l", "l", "l", "l" } },
        { "љ", new [] { null, null, null, null, "l`" } },
        { "м", new [] { "m", "m", "m", "m", "m" } },
        { "н", new [] { "n", "n", "n", "n", "п" } },
        { "њ", new [] { null, null, null, null, "n`" } },
        { "о", new [] { "o", "o", "o", "o", "o" } },
        { "п", new [] { "p", "p", "p", "p", "p" } },
        { "р", new [] { "r", "r", "r", "r", "r" } },
        { "с", new [] { "s", "s", "s", "s", "s" } },
        { "т", new [] { "t", "t", "t", "t", "t" } },
        { "у", new [] { "u", "u", "u", "u", "u" } },
        { "ў", new [] { null, "u`", null, null, null } },
        { "ф", new [] { "f", "f", "f", "f", "f" } },
        { "х", new [] { "x", "x", "x", "x", "x" } },
        { "ц", new [] { "cz", "cz", "cz", "cz", "cz" } },
        { "ч", new [] { "ch", "ch", "ch", "ch", "ch" } },
        { "џ", new [] { null, null, null, null, "dh" } },
        { "ш", new [] { "sh", "sh", "sh", "sh", "sh" } },
        { "щ", new [] { "shh", null, "shh", "sht", null } },
        { "ъ", new [] { "``", null, null, "a`", null } },
        { "ы", new [] { "y`", "y`", null, null, null } },
        { "ь", new [] { "`", "`", "`", "`", null } },
        { "э", new [] { "e`", "e`", null, null, null } },
        { "ю", new [] { "yu", "yu", "yu", "yu", null } },
        { "я", new [] { "ya", "ya", "ya", "ya", null } },
        { "’", new [] { "'", "'", "'", "'", "'" } },
        { "ѣ", new [] { "ye", null, null, "ye", null } },
        { "ѳ", new [] { "fh", null, null, "fh", null } },
        { "ѵ", new [] { "yh", null, null, "yh", null } },
        { "ѫ", new [] { null, null, null, "о`", null } },
        { "№", new [] { "#", "#", "#", "#", "#" } }
    };


    public Dictionary<string, string> CreateCyrillicToLatinDictionary(int lang)
    {
        var result = new Dictionary<string, string>();

        foreach (var p in _data)
        {
            var loCyrillic = p.Key;
            var loLatin = p.Value[lang];

            if (loLatin == null) continue;
			if ((loCyrillic == loLatin) && (loCyrillic.Length == 1))
				continue;

            var upCyrillic = loCyrillic.ToUpper();
            var upLatin = char.ToUpper(loLatin[0]) + loLatin.Substring(1);

            result.Add(loCyrillic, loLatin);
            if (loCyrillic != upCyrillic)
            {
                result.Add(upCyrillic, upLatin);
                if (_crules.IndexOf(upLatin[0]) >= 0)
                {
                    result["ц" + loCyrillic] = "c" + loLatin;
                    result["Ц" + loCyrillic] = "C" + loLatin;
                    result["ц" + upCyrillic] = "c" + upLatin;
                    result["Ц" + upCyrillic] = "C" + upLatin;
                }
            }
        }

        return result;
    }

    public Dictionary<string, string> CreateLatinToCyrillicDictionary(int lang)
    {
        var result = new Dictionary<string, string>();

        foreach (var p in _data)
        {
            var loCyrillic = p.Key;
            var loLatin = p.Value[lang];

            if (loLatin == null) continue;

            var upCyrillic = loCyrillic.ToUpper();
            var upLatin = char.ToUpper(loLatin[0]) + loLatin.Substring(1);

            if (!result.ContainsKey(loLatin))
            {
                result.Add(loLatin, loCyrillic);
                if (!result.ContainsKey(upLatin))
                {
                    result.Add(upLatin, upCyrillic);
                }
            }
        }

        result.Add("c", "ц");
        result.Add("C", "Ц");

        return result;
    }
}

//----------------------------------------------------------------
// FSM Parser
//----------------------------------------------------------------

internal static (string stateName, string fallbackText, Dictionary<char, (int state, string text)> transitions)[] BuildFSM(Dictionary<string, string> replacements)
{
    // Find all states

    var result = GetStates(replacements)
        .OrderBy(s => s.Length)
        .ThenBy(s => s)
        .Select(s => (stateName: s, fallbackText: "", transitions: new Dictionary<char, (int state, string text)>()))
        .ToArray();

    var stateLookup = new Dictionary<string, int>(result.Length);
    for (var i = 0; i < result.Length; i++)
    {
        stateLookup.Add(result[i].stateName, i);
    }
                        
    // Generate simple transitions without output

    foreach (var k in replacements.Keys)
    {
        for (var i = 1; i < k.Length; i++)
        {
            var state = stateLookup[k.Substring(0, i - 1)];
            var input = k[i - 1];
            var output = (stateLookup[k.Substring(0, i)], "");
            if (!result[state].transitions.ContainsKey(input))
            {
                result[state].transitions.Add(input, output);
            }
        }
    }

    // Generate transitions for completed replacements

    foreach (var p in replacements)
    {
        var state = stateLookup[p.Key.Substring(0, p.Key.Length - 1)];
        var input = p.Key[p.Key.Length - 1];
        var output = (0, p.Value);
        if (!result[state].transitions.ContainsKey(input))
        {
            result[state].transitions.Add(input, output);
        }
    }

    // Generate transitions to go back

    for (var state = 1; state < result.Length; state++)
    {
        var tail = result[state].stateName;
        var outputText = "";
        for (; ; )
        {
            string replSource = tail[0].ToString();
            string replTarget = replSource;
            {
                var s = tail;
                while (s.Length > 0)
                {
                    if (replacements.TryGetValue(s, out string value))
                    {
                        replSource = s;
                        replTarget = value;
                        break;
                    }
                    s = s.Substring(0, s.Length - 1);
                }
            }

            outputText += replTarget;
            tail = tail.Substring(replSource.Length);
                    
            if (stateLookup.TryGetValue(tail, out int outputState))
            {
                foreach (var t in result[outputState].transitions)
                {
                    if (!result[state].transitions.ContainsKey(t.Key))
                    {                                
                        var output = (t.Value.state, outputText + t.Value.text);
                        result[state].transitions.Add(t.Key, output);
                    }
                }
                result[state].fallbackText = outputText;
                break;
            }                    
        }
    }

    //

    return result;
}        

private static IEnumerable<string> GetStates(Dictionary<string, string> replacements)
{
    var result = new HashSet<string> { "" };
    foreach (var k in replacements.Keys)
    {
        for (var i = 1; i < k.Length; i++)
        {
            result.Add(k.Substring(0, i));
        }
    }
    return result;
}
#>