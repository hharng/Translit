<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#	
	var langCollection = new (string lang, Func<(string ru, string by, string ua, string bg, string mk), string> selector)[]
	{
		("Russian", t => t.ru),
		("Belorussian", t => t.by),
		("Ukrainian", t => t.ua),
		("Bulgarian", t => t.bg),
		("Macedonian", t => t.mk)
	};
		
	var definitions = new List<(string name, List<string> states, Dictionary<string, Dictionary<string, (string outputState, string outputText)>> transitions)>();

	var rules = new Rules();
	foreach (var l in langCollection)
	{
		var transitions = Parse(rules.CreateCyrillicToLatinDictionary(l.selector));
		var states = transitions.Keys.OrderBy(k => k).ToList();
		definitions.Add(("CyrillicToLatin" + l.lang, states, transitions));
	
		transitions = Parse(rules.CreateLatinToCyrillicDictionary(l.selector));
		states = transitions.Keys.OrderBy(k => k).ToList();
		definitions.Add(("LatinToCyrillic" + l.lang, states, transitions));
	}
#>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Generated at <#=DateTime.Now.ToString("u")#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace NickBuhro.Translit
{
	partial class Transliteration
	{
<# foreach (var md in definitions) { #>
		internal static string <#=md.name#>(string text)
		{
			var index = 0;
			var arr = new char[text.Length<#= md.name[0] == 'C' ? " * 3" : ""  #>];
			
			var state = 0;			
			for (var i = 0; i < text.Length; i++)
			{
				var c = text[i];
				switch (state)
				{
<# foreach (var state in md.states) { #>
					case <#=md.states.IndexOf(state)#>:	// <#=ToLiteral(state)#>
						switch (c)
						{
<# foreach (var t in md.transitions[state].OrderBy(p => p.Key == "").ThenBy(p => p.Key)) { #>
<# if (t.Key != "") { #>
							case <#=ToLiteral(t.Key[0])#>:
<# } else { #>
							default:
<# } #>
<# foreach (var o in t.Value.outputText) { #>
								arr[index++] = <#=ToLiteral(o)#>;
<# } #>
<# if (t.Key == "") { #>
								arr[index++] = c;
<# } #>
<# if (state != t.Value.outputState) { #>
								state = <#=md.states.IndexOf(t.Value.outputState)#>;	// <#=ToLiteral(t.Value.outputState)#>;
<# } #>
								break;
<# } #>
						}
						break;				
<# } #>
				}
			}
<# if (md.states.Count > 1) { #>

			switch (state)
			{
<# foreach (var state in md.states.Where(s => s != "")) { #>
				case <#=md.states.IndexOf(state)#>:	// <#=ToLiteral(state)#>
<# foreach (var o in md.transitions[state][""].outputText) { #>
					arr[index++] = <#=ToLiteral(o)#>;
<# } #>
					break;
<# } #>
			}
<# } #>
			return new string(arr, 0, index);
		}

<# } #>
	}
}
<#+		//----------------------------------------------------------------
		// Helpers
		//----------------------------------------------------------------

		private static string ToLiteral(object input)
        {
            using (var writer = new StringWriter())
            using (var provider = CodeDomProvider.CreateProvider("CSharp"))
            {
                provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
                return writer.ToString();
            }
        }

		//----------------------------------------------------------------
		// Transliteration rules
		//----------------------------------------------------------------

		private sealed class Rules
        {
            private readonly Dictionary<string, (string ru, string by, string ua, string bg, string mk)> _data;

            public Rules()
            {
                _data = new Dictionary<string, (string ru, string by, string ua, string bg, string mk)>
                {
                    { "а", ( "a", "a", "a", "a", "a" ) },
                    { "б", ( "b", "b", "b", "b", "b" ) },
                    { "в", ( "v", "v", "v", "v", "v" ) },
                    { "г", ( "g", "h", "h", "g", "g" ) },
                    { "ѓ", ( "", "", "", "", "g`" ) },
                    { "ґ", ( "", "", "g`", "", "" ) },
                    { "д", ( "d", "d", "d", "d", "d" ) },
                    { "е", ( "e", "e", "e", "e", "e" ) },
                    { "ё", ( "yo", "yo", "", "", "" ) },
                    { "є", ( "", "", "ye", "", "" ) },
                    { "ж", ( "zh", "zh", "zh", "zh", "zh" ) },
                    { "з", ( "z", "z", "z", "z", "z" ) },
                    { "s", ( "", "", "", "", "z`" ) },
                    { "и", ( "i", "", "y`", "i", "i" ) },
                    { "й", ( "j", "j", "j", "j", "" ) },
                    { "j", ( "", "", "", "", "j" ) },
                    { "i", ( "i", "i", "i", "i", "" ) },
                    { "ї", ( "", "", "yi", "", "" ) },
                    { "к", ( "k", "k", "k", "k", "k" ) },
                    { "ќ", ( "", "", "", "", "k`" ) },
                    { "л", ( "l", "l", "l", "l", "l" ) },
                    { "љ", ( "", "", "", "", "l`" ) },
                    { "м", ( "m", "m", "m", "m", "m" ) },
                    { "н", ( "n", "n", "n", "n", "п" ) },
                    { "њ", ( "", "", "", "", "n`" ) },
                    { "о", ( "o", "o", "o", "o", "o" ) },
                    { "п", ( "p", "p", "p", "p", "p" ) },
                    { "р", ( "r", "r", "r", "r", "r" ) },
                    { "с", ( "s", "s", "s", "s", "s" ) },
                    { "т", ( "t", "t", "t", "t", "t" ) },
                    { "у", ( "u", "u", "u", "u", "u" ) },
                    { "ў", ( "", "u`", "", "", "" ) },
                    { "ф", ( "f", "f", "f", "f", "f" ) },
                    { "х", ( "x", "x", "x", "x", "x" ) },
                    { "ц", ( "cz, c", "cz, c", "cz, c", "cz, c", "cz, c" ) },
                    { "ч", ( "ch", "ch", "ch", "ch", "ch" ) },
                    { "џ", ( "", "", "", "", "dh" ) },
                    { "ш", ( "sh", "sh", "sh", "sh", "sh" ) },
                    { "щ", ( "shh", "", "shh", "sht", "" ) },
                    { "ъ", ( "``", "", "", "a`", "" ) },
                    { "ы", ( "y`", "y`", "", "", "" ) },
                    { "ь", ( "`", "`", "`", "`", "" ) },
                    { "э", ( "e`", "e`", "", "", "" ) },
                    { "ю", ( "yu", "yu", "yu", "yu", "" ) },
                    { "я", ( "ya", "ya", "ya", "ya", "" ) },
                    { "’", ( "'", "'", "'", "'", "'" ) },
                    { "ѣ", ( "ye", "", "", "ye", "" ) },
                    { "ѳ", ( "fh", "", "", "fh", "" ) },
                    { "ѵ", ( "yh", "", "", "yh", "" ) },
                    { "ѫ", ( "", "", "", "о`", "" ) },
                    { "№", ( "#", "#", "#", "#", "#" ) }
                };
            }

            public Dictionary<string, string> CreateCyrillicToLatinDictionary(Func<(string ru, string by, string ua, string bg, string mk), string> selector)
            {
                var result = new Dictionary<string, string>();
                foreach (var p in _data)
                {
                    var loCyrillic = p.Key;
                    var loLatin = selector(p.Value);

                    if ((loCyrillic == "ц") || (loLatin == "")) continue;

                    var upCyrillic = loCyrillic.ToUpper();
                    var upLatin = char.ToUpper(loLatin[0]) + loLatin.Substring(1);

                    result.Add(loCyrillic, loLatin);
                    if (!result.ContainsKey(upCyrillic))
                    {
                        result.Add(upCyrillic, upLatin);
                    }
                }

                // Ц - рекомендуется использовать С перед буквами I, Е, Y, J; в остальных случаях CZ
                
                var crules = new[] { 'i', 'e', 'y', 'j', 'I', 'E', 'Y', 'J' };
                foreach (var c in crules)
                {
                    result.Add("ц" + c.ToString(), "c" + c.ToString());
                    result.Add("Ц" + c.ToString(), "C" + c.ToString());
                    
                    foreach (var pair in result.Where(p => p.Value[0] == c).ToList())
                    {
                        result["ц" + pair.Key] = "c" + pair.Value;
                        result["Ц" + pair.Key] = "C" + pair.Value;
                    }
                }

                result.Add("ц", "cz");
                result.Add("Ц", "Cz");

                return result;
            }

            public Dictionary<string, string> CreateLatinToCyrillicDictionary(Func<(string ru, string by, string ua, string bg, string mk), string> selector)
            {
                var result = new Dictionary<string, string>();
                foreach (var p in _data)
                {
                    var loCyrillic = p.Key;
                    var loLatin = selector(p.Value);

                    if ((loCyrillic == "ц") || (loLatin == "")) continue;

                    var upCyrillic = loCyrillic.ToUpper();
                    var upLatin = char.ToUpper(loLatin[0]) + loLatin.Substring(1);

                    if (!result.ContainsKey(loLatin))
                    {
                        result.Add(loLatin, loCyrillic);
                    }

                    if (!result.ContainsKey(upLatin))
                    {
                        result.Add(upLatin, upCyrillic);
                    }
                }

                // Ц                

                result.Add("cz", "ц");
                result.Add("Cz", "Ц");
                result.Add("c", "ц");
                result.Add("C", "Ц");

                return result;
            }
        }

		//----------------------------------------------------------------
		// FSM Parser
		//----------------------------------------------------------------

        internal static Dictionary<string, Dictionary<string, (string outputState, string outputText)>> Parse(IDictionary<string, string> replacements)
        {
            var result = new Dictionary<string, Dictionary<string, (string outputState, string outputText)>>
            {                
                { "", new Dictionary<string, (string outputState, string outputText)>() { { "", ("", "") } } }  // Initial state with fallback loop
            };

            // Generate simple transitions without output

            foreach (var k in replacements.Keys)
            {
                for (var i = 1; i < k.Length; i++)
                {
                    var state = k.Substring(0, i - 1);
                    var input = k[i - 1].ToString();

                    if (!result.ContainsKey(state))
                        result.Add(state, new Dictionary<string, (string outputState, string outputText)>());

                    if (!result[state].ContainsKey(input))
                        result[state].Add(input, (k.Substring(0, i), ""));
                }
            }

            // Generate transitions for completed replacements

            foreach (var p in replacements)
            {
                var state = p.Key.Substring(0, p.Key.Length - 1);
                var input = p.Key[p.Key.Length - 1].ToString();

                if (!result.ContainsKey(state))
                    result.Add(state, new Dictionary<string, (string outputState, string outputText)>());

                if (!result[state].ContainsKey(input))
                    result[state].Add(input, ("", p.Value));
            }            

            // Generate transitions to go back
            
            foreach (var state in result.Keys.Where(s => s != "").OrderBy(s => s.Length).ToList())
            {
                var tail = state;
                var output = "";
                for (; ; )
                {
                    var replacement = FindReplacement(replacements, tail);

                    output += replacement.output;
                    tail = tail.Substring(replacement.source.Length);

                    
                    if (result.TryGetValue(tail, out Dictionary<string, (string outputState, string outputText)> list))
                    {
                        foreach (var t in list)
                        {
                            if (!result[state].ContainsKey(t.Key))
                                result[state].Add(t.Key, (t.Value.outputState, output + t.Value.outputText));
                        }
                        break;
                    }
                }
            }

            //

            return result;
        }

        private static (string source, string output) FindReplacement(IDictionary<string, string> replacements, string value)
        {
            var s = value;
            while (s.Length > 0)
            {
                if (replacements.TryGetValue(s, out string result))
                    return (s, result);

                s = s.Substring(0, s.Length - 1);
            }

            s = value.Substring(0, 1);
            return (s, s);
        }
#>